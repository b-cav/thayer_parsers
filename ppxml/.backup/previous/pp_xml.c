/* 
 * pp_xml.c --- generates xml state machine description
 * 
 * Author: Ellie Baker and Stephen Taylor
 * Created: 11-23-2020
 * Version: 2.0
 * 
 * Description: This program take as input the grammer and state
 * machine generated by hammer and creates an xml file describing the
 * LALR automaton in a form consistent with Bison.
 */
 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include "pp_xml.h"

#define MAXLINE 256
#define MAXRHS 10
#define MAXTABLE 1000
/* structure of a rule */
typedef struct ruleinfo {
	char *lhs;
	int rhslen;
	char *rhs[MAXRHS];
} rule_t;

/* the rule table */
static rule_t *ruletable[MAXTABLE];
static int nextrule=0; 
/* table of nonterminals */
static char *nonterminals[MAXTABLE];
static int next_nt=0;
/* table of terminals */
static char *terminals[MAXTABLE];
static int next_t=0;

int e = 0;
int a = 0;


static bool save_nt(char *symbol) {
	int i;
	for(i=0; i<next_nt; i++)
		if(strcmp(nonterminals[i],symbol)==0)
			return false;
	nonterminals[next_nt++]=symbol;
	return true;
}

static bool save_t(char *symbol) {
	int i;
	for(i=0; i<next_t; i++)
		if(strcmp(terminals[i],symbol)==0)
			return false;
	terminals[next_t++]=symbol;
	return true;
}

//called prior to printing
static char *tostring(uint8_t c) {
	char buff[MAXLINE];
	char *strp;

	sprintf(buff,"%c",(char)c);
	if((strp=(char*)malloc(strlen(buff)+1))==NULL) {
		printf("error: unable to allocate string\n");
		return NULL;
	}
	strcpy(strp,buff);
	return strp;
}

static bool matchrule(rule_t *rp1, rule_t *rp2) {
	int i;
	/*	char *p; */
	
	if(strcmp(rp1->lhs,rp2->lhs)!=0) /* lhs not the same same */
		return false;
	
	if(rp1->rhslen != rp2->rhslen) /* elements in right not same */
		
		return false;
	for(i=0; i<(rp1->rhslen); i++) {
		if(rp1->rhs[i]==NULL && rp2->rhs[i]!=NULL)  
			return false;
		if(rp1->rhs[i]!=NULL && rp2->rhs[i]==NULL)
			return false;
		if(rp1->rhs[i]!=NULL && strcmp(rp1->rhs[i],rp2->rhs[i])!=0)
			return false;
	}
	return true;
}

/*
 * match_rules() -- matches a rule in the ruletable
 * returns: the index of the matching rule; -1 otherwise
 */
static int match_rules(rule_t *rp) { 
	int i;
	rule_t *rtp;
	
	for(i=0; i<nextrule; i++) {
		rtp = ruletable[i];
		if(matchrule(rp,rtp)) 
			return i;
	}
	return -1;
}

static rule_t *make_empty_rule() {
	rule_t *rp;
	int i;
	
	if((rp = (rule_t*)malloc(sizeof(rule_t)))==NULL)
		return NULL;
	rp->lhs = NULL;
	rp->rhslen = 0;
	for(i=0; i<10; i++) {
		rp->rhs[i] = NULL;
	}
	return rp;
}

/* 
 * Build a nonterminal name in malloc'd space
 */
static char *nonterminal_name(const HCFGrammar *g, const HCFChoice *nt)
{
	char buf[16] = {0}; // 14 characters in base 26 are enough for 64 bits
	int i;
	char *np,*sp;
	size_t n;
  // find nt's number in g
  n = (uintptr_t)h_hashtable_get(g->nts,nt);
  for(i=14; i>=0 && (n>0 || i==14); i--) { // NB start symbol (number 0) is always "A"
    buf[i] = 'A' + n%26;
    n = n/26;   // shift one digit
  }
	sp=buf+i+1;										/* find start of string */
	if((np=malloc(strlen(sp)+1))==NULL) { /* copy the string */
		printf("error: unable to create nonterminal name %s\n",sp);
		return NULL;
	}
	strcpy(np,sp);
	save_nt(np);
  return np;
}

#if 0
static char *build_string(HCFChoice **p) {
	char *sp,buff[128],*bp;
	for(bp=buff ; *p!=NULL && (*p)->type==HCF_CHAR; p++)
		*bp++ = (*p)->chr;
	*bp='\0';
	sp = (char*)malloc(strlen(buff)+1);
	strcpy(sp,buff);
	return sp;
}
#endif 

static int getval(char *cp) {
	unsigned int val;
	if(sscanf(cp,"\\x%x",&val)==1) /* scanned a hex value */
		return (int)val;
	else if(strcmp(cp,"\\-")==0)
		return 45;
	else if(strcmp(cp,"\\]")==0) 
		return 93;
	else if(strcmp(cp,"\\t")==0)
		return 9;
	else if(strcmp(cp,"\\n")==0)
		return 10;
	else if(strcmp(cp,"\\r")==0)
		return 13;
	else if(strcmp(cp,"\\b")==0)
		return 8;
	else if(strcmp(cp,"\"")==0)
		return 34;
	else if(strcmp(cp,"\'")==0)
		return 39;
	else if(strcmp(cp,"\\")==0)
		return 92;
	else if(strcmp(cp,"&amp;")==0)
		return 38;
	else if(strcmp(cp,"&lt;")==0)
		return 60;
	else if(strcmp(cp,"&gt;")==0)
		return 62;
	else if(strcmp(cp,"&quot;")==0)
		return 34;
	else if(strcmp(cp,"&apos;")==0)
		return 39;
	else
    return (int)(*cp);
}

/* turn esc characters into a two char sequence */
static char *esc(uint8_t c) {
	char buff[16],*cp;
	
	if((c>=0x00 && c<=0x07) || (c>=0x0B && c<=0x0C) ||
		 (c>=0x0E && c<=0x1F) || (c>=0x7F  && c<=0xFF ))  /* c is binary value */
		sprintf(buff,"\\x%02" PRIX8 "",c); /* make printable as hex */
	else {
		switch(c) {
			case 0x08: sprintf(buff,"\\b"); break;
			case 0x09: sprintf(buff,"\\t"); break;
			case 0x0A: sprintf(buff,"\\n"); break;
			case 0x0C: sprintf(buff,"\\f"); break;
			case 0x0D: sprintf(buff,"\\r"); break;
			case 0x5C: sprintf(buff,"\\"); break;
	
			case 0x26: sprintf(buff, "&amp;"); break;
			case 0x3C: sprintf(buff, "&lt;"); break;
			case 0x3E: sprintf(buff, "&gt;"); break;
			case 0x22: sprintf(buff, "&quot;"); break;
			case 0x27: sprintf(buff, "&apos;"); break;
			
			default: sprintf(buff,"%c",(char)c); break;
		}
	}
	
	if((cp = (char*)malloc(strlen(buff)+1))==NULL) {
		printf("error: unable to generate esc char\n");
		return NULL;
	}
	strcpy(cp,buff);
	return cp;
}


static void add_singleton(char *lhs,uint8_t i) {
	char *cp;
	rule_t *rp;
	
	cp = esc(i);
	rp = make_empty_rule();
	rp->lhs = lhs;
	rp->rhslen = 1;
	rp->rhs[0] = cp;
	save_t(cp);
	ruletable[nextrule++] = rp;
}

#define NUMCHARS 256						/* the number of ascii values */
#define MAXCHARSET (NUMCHARS+3)	/* 256 ascii values + '[' ']' and '\0' */
/*
 * build a new nonterminal represneting a charset and a set of rules
 * for each element in the set. Note that if - or ] are in a charset
 * they are escaped. This required a fix to the hammer sources.
 */
static char *build_charset_expanded(const HCharset cs) {
	char buff[MAXCHARSET],buff1[MAXCHARSET],*ntp,*bp;
	int i,min,max,cnt;
	bool range;
	
	/* figure out what is in the charset */
	bp=buff;	
	for(cnt=0, min=-1, max=-1, i=0; i<NUMCHARS; i++) 
		if(charset_isset(cs,i)) {		/* true if i is in charset */
			//printf("%x\n",i);
			*bp++=i;									/* add char to enumerated set */
			cnt++;										/* count the number of chars in set */
			if(min<0) 								/* min not yet set */
				min=i;									/* set min value at first entry */
			max=i;										/* save current value as max */
		}
	//	printf("buff: %s\n",buff);
	/* scan the enumerated characters in buff */
	for(range=true, i=0; range && i<cnt-1; i++)
		if(buff[i]+1!=buff[i+1])	/* buff contents are not consecutive */
			range = false;					/* its an enumeration not a range */
	
	/* start building the automaton representation for a charset */
	strcpy(buff1,"[");						/* [....] */
	if(range) {										/* consecutive range use min and max */
		strcat(buff1,esc(min));	 
		if(max>min+1) 							/* consecutive & > 2 entries use [x-Y] */
			strcat(buff1,"-");				/* consecutive & 2 entires use [xy] */
		if(min!=max) {								/* consecutive and 1 entry use [x] */
			strcat(buff1,esc(max));
		}
	}
	else {												/* its an enumeration, escape every value */
		for(i=0; i<cnt; i++) {;
			strcat(buff1,esc(buff[i]));
		}
	}
	strcat(buff1,"]");						/* end the representation */
	/* build a non-terminal string from range representation */
	if((ntp = (char*)malloc(strlen(buff1)+1))==NULL) {				
		printf("error: unable to create charset\n");
		return NULL;
	}
	strcpy(ntp,buff1);						/* use buff1 as a nonterminal */
	if(save_nt(ntp)) {						/* if its not been seen before */
		if(range)
			for(i=min; i<=max; i++)	/* make rules for each element of range */
				add_singleton(ntp,i);
		else
			for(i=0; i<cnt; i++)	/* make rules for each element of enumeration */
				add_singleton(ntp,buff[i]);
	}
	return ntp;
}

static char *build_rhs_element(const HCFGrammar *g, const HCFChoice *x) {
	char *rip;										/* ptr to ith element of rhs of rule */
	switch(x->type) {
	case HCF_END:
		rip = (char*)malloc(5);
		strcpy(rip,"$end");
		break;
	case HCF_CHAR:								/* terminal symbol */
		rip = (char*)malloc(2);
		rip = esc(x->chr);
		//*rip = x->chr;
		//*(rip+1) = '\0';
		save_t(rip);
		break;
	case HCF_CHARSET:
		rip = build_charset_expanded(x->charset);
		break;
	default:
		rip = nonterminal_name(g,x);
		break;
	}
	return rip;
}

/*
 * build a set of rules that share the same left hand side
 */
static int build_rule(char *lhs,const HCFGrammar *g,const HCFSequence *seq) {
	HCFChoice **x;
	rule_t *rp;
	int i;
	char *rhsp;
	
	//	printf("build_rule\n");
	rp = make_empty_rule();			/* make an empty rule */
	rp->lhs = lhs;							/* with this lhs */
	x = seq->items;							/* x is the rhs items */
	if(*x!=NULL) {							/* nonempty rhs */
		i=0;
		while(*x) {
			if((rhsp = build_rhs_element(g,*x))==NULL) {
				printf("error: unexpected empty rhs on rule %d\n",nextrule);
				return -1;
			}
			rp->rhs[i++] = rhsp;
			if(i>MAXRHS) {
				printf("error: too many terms on rule %d rhs\n",nextrule);
				return -1;
			}
			x++;
		}
		rp->rhslen = i;							/* set the lenght of the rhs */
	}
	ruletable[nextrule++] = rp;	/* put in the ruletable */
	return 0;
}

static int build_rule_sequence(const HCFGrammar *g,const HCFChoice *nt) {
	HCFSequence **p;
	char *lhs;
	
	if((lhs = nonterminal_name(g,nt))==NULL) { /* build lhs nonterminal string */
		printf("error: unable to build nonterminal on rule lhs\n");
		return -1;
	}
	p=nt->seq;										/* sequence of associated rhs's */
	if(*p==NULL) {								/* should not happen */
		printf("error: invalid rule choice\n");
		return -1;
	}
	for( ; *p!=NULL ; p++)				/* for each sequence */
		if(build_rule(lhs,g,*p)!=0) {			/* these rules use same lhs */
			printf("error: unable to build rules\n");
			return -1;
		}
	return 0;
}


static int build_ruletable(const HCFGrammar *g) {
	int i;
  HHashTableEntry *hte;
	
	/* place $end as the first terminal symbol */
  if (g->nts->used < 1) {
		printf("error: no nonterminals in grammar!\n");
    return -1;
  }
  for(i=0; i<g->nts->capacity; i++) { 
    for(hte=&g->nts->contents[i]; hte!=NULL; hte = hte->next) {
      if(hte->key != NULL) {
				if(build_rule_sequence(g,hte->key)!=0) {
					printf("error: unable to build rule sequence\n");
					return -1;
				}
			}
		}
	}
	return 0;
}

static void putline(FILE *fp, char *line, int tab) {
	int i;
	for(i=0; i<tab; i++) {
		fprintf(fp,"  ");
		fflush(fp);
	}
	fprintf(fp,"%s",line);
}

static void print_grammar(FILE *fp) {
	int i,j;
	rule_t *rp;
	char line[MAXLINE], *p;
	
	putline(fp,"<grammar>\n",1);
	
	putline(fp,"<rules>\n",2);
	for (i=0; i<nextrule; i++) {
		rp = ruletable[i];
		sprintf(line,"<rule number=\"%d\">\n",i);
		putline(fp,line,3);
		sprintf(line,"<lhs>");
		p=rp->lhs;
		while(*p!='\0') {
		  strcat(line, tostring(*p));
		  p++;
		}
		strcat(line, "</lhs>\n");
		putline(fp,line,4);
		putline(fp,"<rhs>\n",4);
      if (rp->rhslen == 0)
        putline(fp,"<empty/>\n",5);
      else {
        for (j=0; j<rp->rhslen; j++) {
          if(rp->rhs[j]==NULL)
		  	fprintf(fp,"?\n");
		  sprintf(line, "<symbol>");
		  p=rp->rhs[j];
		  while(*p!='\0') {
		    strcat(line, tostring(*p));
			p++;
		  }
		  strcat(line, "</symbol>\n");
		  putline(fp,line,5);
        }
      }
      putline(fp,"</rhs>\n",4);
      putline(fp,"</rule>\n",3);
  }
  putline(fp,"</rules>\n",2);
	
	putline(fp,"<terminals>\n",2);
	for(i=0; i<next_t; i++) {
		sprintf(line,"<terminal symbol-number=\"%d\" token-number=\"%d\" name=\"\'", i,getval(terminals[i]));
		p=terminals[i];
		while(*p!='\0') {
			strcat(line, tostring(*p));
			p++;
		}
		 strcat(line, "'\"/>\n");
		putline(fp,line,3);
	}
	putline(fp,"</terminals>\n",2);		
	
	
	putline(fp,"<nonterminals>\n",2);
	for(j=0; j<next_nt; j++) {
		sprintf(line,"<nonterminal symbol-number=\"%d\" name = \"",(j+i));
		p=nonterminals[j];
		while(*p!='\0') {
	    	strcat(line,tostring(*p));
			p++;
		}
		strcat(line,"\"/>\n");
		putline(fp,line,3);
	}
	putline(fp,"</nonterminals>\n",2);
	putline(fp,"</grammar>\n",1);
}

/*
 * print_input() -- print the original hammer input into a comment
 * within the xml output after the xml version line
 */
void print_input(FILE *fp,HParser *p) {
  HAllocator *mm__ = &system_allocator;
	HCFGrammar *g;
	
	fprintf(fp, "<!--\n");
	fprintf(fp,"\n==== G R A M M A R ====\n");
	if((g=h_cfgrammar_(mm__,h_desugar_augmented(mm__,p)))==NULL) {
		fprintf(fp,"[Grammar not available]\n");
		exit(EXIT_FAILURE);
	}
  h_pprint_grammar(fp,g,0); 
	fprintf(fp,"\n==== STATE MACHINE ====\n");
	h_pprint_lrtable(fp,g,(HLRTable*)p->backend_data,0);
	fprintf(fp, "\n-->\n");
}



static char *build_charset(const HCharset cs) {
	char buff[NUMCHARS],buff1[MAXCHARSET],*ntp,*bp;
	int i,min,max,cnt;
	bool range;
	
	/* figure out what is in the charset */
	bp=buff;	
	for(cnt=0, min=-1, max=-1, i=0; i<NUMCHARS; i++) 
		if(charset_isset(cs,i)) {		/* true if i is in charset */
			//printf("%x\n",i);
			*bp++=i;									/* add char to enumerated set */
			cnt++;										/* count the number of chars in set */
			if(min<0) 								/* min not yet set */
				min=i;									/* set min value at first entry */
			max=i;										/* save current value as max */
		}
	//	printf("buff: %s\n",buff);
	/* scan the enumerated characters in buff */
	for(range=true, i=0; range && i<cnt-1; i++)
		if(buff[i]+1!=buff[i+1])	/* buff contents are not consecutive */
			range = false;					/* its an enumeration not a range */
	
	/* start building the automaton representation for a charset */
	strcpy(buff1,"[");						/* [....] */
	//single value gets picked up as a range
	if(range) {										/* consecutive range use min and max */
		strcat(buff1,esc(min));
		if(max>min+1) {							/* consecutive & > 2 entries use - */
			strcat(buff1,"-");
		}			
		if(min!=max) {								/* consecutive and 1 entry use [x] */
			strcat(buff1,esc(max));
		}
	}
	else {										/* its an enumeration, escape every value */
		for(i=0; i<cnt; i++) {
			strcat(buff1,esc(buff[i]));
		}
	}
	strcat(buff1,"]");						/* end the representation */
	/* build a non-terminal string from range representation */
	if((ntp = (char*)malloc(strlen(buff1)+1))==NULL) {				
		printf("error: unable to create charset\n");
		return NULL;
	}
	strcpy(ntp,buff1);						/* use buff1 as a nonterminal */
	
	return ntp;
}

static char *build_rhs_reduction(const HCFGrammar *g, const HCFChoice *x) {
	char *rip;										/* ptr to ith element of rhs of rule */
	switch(x->type) {
	case HCF_END:
		rip = (char*)malloc(5);
		strcpy(rip,"$end");
		break;
	case HCF_CHAR:							/* terminal symbol */
		rip = (char*)malloc(2);
		rip = esc(x->chr);
		save_t(rip);
		break;
	case HCF_CHARSET:
		//the rhs issue is in this case
		rip = build_charset(x->charset);
		break;
	default:
		rip = nonterminal_name(g,x);
		break;
	}

	return rip;
}


static int build_reduction(char *lhs, const HCFGrammar *a, const HCFSequence *seg) {
	int i,j;
	char *rhsp;
	int rulematch;
	rule_t *currrule;
	
  HCFChoice **x = seg->items;
	
	currrule = make_empty_rule();
	currrule->lhs = lhs;
	
	if(*x!=NULL) {                            /* nonempty rhs */
		i=0;
		while(*x) {
			if((rhsp = build_rhs_reduction(a,*x))==NULL) {
				printf("error: empty rhs on rule %d\n",nextrule);
				return -1;
			}
			currrule->rhs[i++] = rhsp;
			if(i>MAXRHS) {
				printf("error: too many terms on rule %d rhs\n",nextrule);
				return -1;
			}
			x++;
		}
		currrule->rhslen = i;                            /* set the lenght of the rhs */
	}
	if(match_rules(currrule)<0) {
    printf("error: match failed: ");
    printf("%s -> ", currrule->lhs);
		if(currrule->rhslen==0)
			printf("\"\"");
		else {
			for (i=0; i<currrule->rhslen; i++) {
				rhsp = currrule->rhs[i];
				printf("%s (", rhsp);
				for(j=0; j<strlen(rhsp); j++)
					printf("%02x ",*rhsp++);
				printf(") ");
			}
		}
    printf("    ---- (%d rhs terms)\n", currrule->rhslen);
	}
	rulematch = match_rules(currrule);
	return rulematch;
}

static void print_reduction_default(FILE *f, const HCFGrammar *g, const HLRAction *action,bool *pp)
{
  char *lhs;
  int rulematch;
  char line[MAXLINE];
	
  if (action->type == HLR_REDUCE) { //just an extra check this should happen
		//WORKING: logging the LHS
		lhs = build_rhs_reduction(g, action->production.lhs);
    //WORKING: logging the RHS
		
    HCFSequence seqred = {action->production.rhs};
    rulematch = build_reduction(lhs,g,&seqred);
    if (rulematch == -1) {            /* these rules use same lhs */
      printf("error: unable to build rules\n");
    }
		if(!(*pp))
			putline(f,"<reductions>\n",4);
		*pp=true;										/* signify reductions are present */
		if (strcmp(lhs, "$end") == 0)  //is it this or $??????
			sprintf(line,"<reduction symbol= \"$end\" rule=\"%d\"/>\n", rulematch);
		else
			sprintf(line,"<reduction symbol= \"$default\" rule=\"%d\"/>\n", rulematch);	/* signify reductions are present */
		putline(f,line,5);
  }
  else
    printf("error, not a reduction");
}


static void print_reductions(FILE *f, const HCFGrammar *g, const HStringMap *map, bool *pp) {
	char line[MAXLINE], *lhs, *transition;
	int rulematch;
	
	
	/*finds and prints $end reduction*/
	if (map->end_branch) {
		void *val = map->end_branch;
		const HLRAction *action = val;
    
		if(action->type == HLR_REDUCE) { //if it's a reduction...
			if(!(*pp))
				putline(f, "<reductions>\n",4);
			*pp=true;    /*we have at least one transition*/
			
			lhs = build_rhs_reduction(g, action->production.lhs);
			HCFSequence seqend = {action->production.rhs};
			rulematch = build_reduction(lhs, g, &seqend);
			if (rulematch<0)
				printf("error: unable to find rule\n");
			sprintf(line,"<reduction symbol= \"$end\" rule=\"%d\"/>\n", rulematch);
			putline(f,line,5);
		}
	}
	
	/*moves through all terminal reductions*/ 
	HHashTable *ht = map->char_branches; 
	size_t i;
	HHashTableEntry *hte;
	for(i=0; i < ht->capacity; i++) {
		for(hte = &ht->contents[i]; hte; hte = hte->next) {
			if (hte->key == NULL) {
				continue;
			}
			uint8_t c = key_char((HCharKey)hte->key);
			HStringMap *ends = hte->value;
			transition = esc(c); 
			
			/*this is for terminal reductions that are not $end*/
			if (ends->epsilon_branch) {
				void *val = ends->epsilon_branch;
				const HLRAction *action = val;
				if (action->type == HLR_REDUCE) { /*if it's a reduction...*/
					if(!(*pp))
						putline(f, "<reductions>\n",4);
					*pp=true;    /*we have at least one transition*/
					lhs = build_rhs_reduction(g, action->production.lhs);
					HCFSequence seq = {action->production.rhs};
					rulematch= build_reduction(lhs, g, &seq);
					sprintf(line,"<reduction symbol= \"\'%s\'\" rule=\"%d\"/>\n", transition, rulematch);
					putline(f,line,5);
				}
			}
		}
	}
}

static void print_shift(FILE *f, const HStringMap *map,bool *pp) {	
	/*print shifts*/
	char line[MAXLINE];
	char *transition;
	
	//identifies $end transition and prints
	if (map->end_branch) { 
		void *longshot = map->end_branch;
		const HLRAction *actiontest = longshot;
		
		if(actiontest->type != HLR_REDUCE) { //if it's a $end symbol...
			if(!(*pp))
					putline(f,"<transitions>\n",4); //this is the issue spot
			*pp = true;
			sprintf(line,"<transition type = \"shift\" symbol = \"$end\" state =\"%zu\"/>\n",
							actiontest->nextstate); //where end of input dollar is printed
			putline(f,line,5);
		}
	}
		
	/*this iterates through all terminal transitions (not $end transitions though)*/
	HHashTable *ht = map->char_branches; 
	size_t i;
	HHashTableEntry *hte;
	for(i=0; i < ht->capacity; i++) { //reaches capacity before exiting
		for(hte = &ht->contents[i]; hte; hte = hte->next) {
			if (hte->key == NULL) {
				continue;
			}
			uint8_t c = key_char((HCharKey)hte->key);
			HStringMap *ends = hte->value;
			transition = esc(c);
			
			//all terminal transitions (excluding $end)
			if (ends->epsilon_branch) {
				void *val = ends->epsilon_branch;
				const HLRAction *action = val;
				if (action->type != HLR_REDUCE) {
					if(!(*pp))
						putline(f,"<transitions>\n",4);
					*pp = true;
					sprintf(line,"<transition type = \"shift\" symbol = \"\'%s\'\" state =\"%zu\"/>\n",
									transition, action->nextstate);
					putline(f,line,5);
				}
			}
			
			
		}
	}
}


static void print_goto(FILE *f, const HCFGrammar *g, const HCFChoice *symbol, const HLRAction *action,bool *pp) {
  char line[MAXLINE],statestr[MAXLINE], *p;
  
	if(!(*pp))
		putline(f, "<transitions>\n",4);
	
	*pp=true;    /*we have at least one transition*/
	
	switch(action->type) {
		case HLR_SHIFT:
			if(action->nextstate == HLR_SUCCESS)
				strcpy(statestr,"\"$accept\"");
			else
				sprintf(statestr,"\"%zu\"", action->nextstate);
			break;
			default:
				strcpy(statestr,"????");
				printf("error: see old version for deleted response");
	}
		/*determine symbol*/
	switch(symbol->type) {
		case HCF_END:                                 /* fall through */
		case HCF_CHAR:
			sprintf(line, "<transition type = \"goto\" symbol = \"%c\" state = %s/>\n",
							symbol->chr,statestr);
			printf("error: %c - terminal encountered in goto transition, state %s \n",
						 symbol->chr,statestr);
			break;
		case HCF_CHARSET:
			sprintf(line, "<transition type = \"goto\" symbol = \"");
			p=build_charset(symbol->charset);
			while(*p!='\0') {
				strcat(line,tostring(*p));
				p++;
			}
			strcat(line,"\" state = ");
			strcat(line, statestr);
			strcat(line, "/>\n");
			break;
		default:
			if ((symbol->type) != HCF_CHARSET) {
				sprintf(line, "<transition type = \"goto\" symbol = \"%s\" state = %s/>\n",
								nonterminal_name(g, symbol), statestr);
			}
			break;
		}
		putline(f,line,5);
}

//separates and calls functions for terminal, nt, and reduction transitions
static void print_statemc(FILE *f, const HCFGrammar *g, const HLRTable *table,
													unsigned int indent) {
  char line[MAXLINE];
	bool present;							/* true if a transitons are present */
	
  putline(f,"<automaton>\n",1);
  for(size_t i=0; i<table->nrows; i++) { /* for each state in that automaton */
		
		fprintf(f,"\n");						/* designate the state */
    sprintf(line, "<state number = \"%zu\">\n", i);
    putline(f,line,2);
    putline(f,"<actions>\n",3);
		
    if(table->ntmap[i] != NULL){ 
			present=false;						/* print the transitons */
			H_FOREACH(table->ntmap[i], HCFChoice *symbol, HLRAction *action)
				print_goto(f, g, symbol, action, &present);
			H_END_FOREACH;
			print_shift(f,table->tmap[i],&present);
			if(present) 							/* transitions present */
				putline(f,"</transitions>\n",4); /* terminate them */
			else
        putline(f,"<transitions/>\n",4); /* signify none */
			
			present=false;				 /* print the reductions */
      if(table->forall[i]) { //if there is only a reduction in this state
				print_reduction_default(f, g, table->forall[i],&present);
				if(!h_lrtable_row_empty(table, i)) //an error check
					printf("error: unknown reduction\n");
			}
			print_reductions(f, g, table->tmap[i], &present);
			
			if(present) 							/* reductions were present */
				putline(f,"</reductions>\n",4); /* terminate the list of reductions */
			else
				putline(f,"<reductions/>\n",4); /* othersize, signify none */
			
			putline(f,"</actions>\n",3); /* wind up the actions and state */
			putline(f,"</state>\n",2);
    }
  }
  putline(f,"</automaton>\n",1);
}


int pp_xml(char *pn,HParser *parser) {
	
  /* generate the output file */
  char fn[128];
  /* generate a file name for the output XML file */
  strcpy(fn,pn);
  strcat(fn,".xml");
  printf("[Generating %s...",fn);
  fflush(stdout);
	
  /* open the XML file for writing -- fp now points to the file */
  FILE *fp;
  if((fp=fopen(fn,"w"))==NULL) {
    printf("[unable to open %s]\n",fn);
    return -1;
  }
  /* finess grammar to include a unique start rule */
  HAllocator *mm__ = &system_allocator;
  HCFGrammar *g = h_cfgrammar_(mm__,h_desugar_augmented(mm__,parser));
  if (g == NULL) {
    fprintf(fp,"h_cfgrammar failed\n");
    return -1;
  }
	
	putline(fp, "<?xml version=\"1.0\"?>\n", 0);
	print_input(fp,parser);
	
	if(build_ruletable(g)==0) {
		putline(fp,"\n<hammer-xml-report version=\"1.0.0\">\n",0);
		print_grammar(fp);
		print_statemc(fp,g,parser->backend_data,0);
		fprintf(fp,"</hammer-xml-report>\n");
	}
  fclose(fp);
  printf("]\n");
  return 0;
}
